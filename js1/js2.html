<script>
   console.log( !!' ' + !!'' - !!false || '不通过')
   window.a || (window.a = '1')
   console.log(window.a)

   /*
      函数的作用域 和作用域链 AO(active Object 函数自身定义的变量和自身的子函数) 
      GO(Globle Object 全局对象其实就是window  就是定义再全局的一些变量
      和函数 如果自身是个全局函数 那这个函数的GO中也包阔自己)
      
      函数的执行过程: 当函数被定义的时候 会生成一个[scope]对象 scope保存
      着该函数的作用域链  作用域链的第0项保存着函数的GO 当函数被调用的前一
      刻,生成该函数的AO AO中保存这函数自身的变量等 AO会添加到函数作用域链
      的第1位,将GO挤到自己后面,当函数执行的时候 如果访问一个变量 函数会优
      先从自身的AO上面找 如果找不到就会去找GO上面的
      
      如果函数内部又定义了一个函数 并且调用了这个函数 不会生成新的GO他们共享
      一个GO 但新的函数会生成自己的AO并且排列再父级函数的前面 当查找一个变量
      的时候 会首先从自身的AO中查找 如果找不到就去父级的AO中查找 依次这样...
      如果父级的AO中也没有 就去GO中查找

      当父级函数执行完毕 函数的AO会销毁 因为内部函数保存在父级函数的AO中
      父级函数的AO销毁 所以子函数也会被销毁 随后父级函数的状态变为定义状态
   
   */

  function a(){   //父级函数
      function b(){  //子函数
         var c =1
      }
      var d = 2
      b()
  }
  a() //执行父级函数
</script> 